<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hyper-Realistic Oil Painting Simulator</title>
    <style>
        :root { --bg-color: #1a1a1a; --panel-bg: #2d2d2d; --text-color: #e0e0e0; --accent: #ff9800; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: var(--bg-color); color: var(--text-color); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; touch-action: none; }
        #app { display: flex; flex-direction: column; height: 100%; }
        
        /* Toolbar */
        #toolbar {
            background-color: var(--panel-bg); padding: 8px; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; 
            border-bottom: 1px solid #444; z-index: 10; justify-content: space-between;
        }
        .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        
        button {
            background: #444; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; 
            font-size: 0.85rem; transition: 0.2s; user-select: none;
        }
        button:hover { background: #555; }
        button.active { background: var(--accent); color: #000; font-weight: bold; box-shadow: 0 0 8px rgba(255,152,0,0.4); }
        
        .slider-group { display: flex; align-items: center; gap: 4px; background: rgba(0,0,0,0.2); padding: 4px 8px; border-radius: 4px; }
        input[type="range"] { width: 70px; cursor: pointer; }
        input[type="color"] { border: none; width: 28px; height: 28px; cursor: pointer; background: none; }
        
        /* Canvas Area */
        #canvas-container {
            flex: 1; position: relative; background-color: #f0f0f0; /* Canvas paper */
            background-image: radial-gradient(#e0e0e0 1px, transparent 1px); background-size: 20px 20px;
            overflow: hidden; cursor: crosshair; 
        }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        
        /* HUD */
        #status { position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 4px; font-size: 0.8rem; pointer-events: none; opacity: 0; transition: opacity 0.5s; }
        
        @media (max-width: 600px) {
            #toolbar { overflow-x: auto; justify-content: flex-start; padding: 5px; gap: 5px; }
            .controls { flex-wrap: nowrap; }
            button { font-size: 0.75rem; padding: 5px 8px; }
            input[type="range"] { width: 50px; }
        }
    </style>
</head>
<body>

<div id="app">
    <div id="toolbar">
        <div class="controls">
            <div class="slider-group">
                <label>Color</label>
                <input type="color" id="color-picker" value="#e74c3c">
            </div>
            <div class="slider-group">
                <label>Size</label>
                <input type="range" id="size-slider" min="5" max="80" value="30">
            </div>
            <div class="slider-group">
                <label>Wetness</label>
                <input type="range" id="wet-slider" min="1" max="100" value="80" title="How wet the paint is (drying time)">
            </div>
            <div class="slider-group">
                <label>Viscosity</label>
                <input type="range" id="visc-slider" min="1" max="100" value="40" title="Paint thickness (Flow)">
            </div>
        </div>
        <div class="controls">
            <button id="btn-smooth" class="active">Round</button>
            <button id="btn-texture">Textured</button>
            <button id="btn-knife">Palette Knife</button>
            <button id="btn-undo">Undo</button>
            <button id="btn-clear">Clear</button>
            <button id="btn-save">Save</button>
            <button id="btn-load">Load</button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="art-canvas"></canvas>
    </div>

    <div id="status">Action</div>
</div>

<!-- LocalForage for storage -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>

<script>
/**
 * PHYSICS-BASED OIL PAINT SIMULATION
 * 
 * Logic:
 * 1. Particles: Paint is applied as discrete "dabs" (particles).
 * 2. Rendering: Dabs are drawn as textured shapes with noise.
 * 3. Wetness: Each particle has a 'wetness' value. Wet particles interact.
 * 4. Smearing: If the brush moves over wet particles, they are displaced (advection).
 * 5. Drying: Wetness decreases over time.
 * 6. Optimization: Spatial Hash Grid for collision detection O(1) instead of O(N^2).
 */

const canvas = document.getElementById('art-canvas');
const ctx = canvas.getContext('2d', { alpha: false }); // No transparency on bg for perf
const container = document.getElementById('canvas-container');

// --- Configuration & State ---
const state = {
    isDrawing: false,
    tool: 'smooth', // smooth, texture, knife, erase
    color: '#e74c3c',
    size: 30,
    wetness: 0.8, // 0 to 1
    viscosity: 0.4, // 0 to 1 (Flow rate)
    lastX: 0,
    lastY: 0,
    particles: [], // Active wet particles
    maxParticles: 3000, // Limit to prevent lag
    undoStack: [],
    maxUndo: 10,
    hueOffset: 0
};

// UI Elements
const ui = {
    color: document.getElementById('color-picker'),
    size: document.getElementById('size-slider'),
    wet: document.getElementById('wet-slider'),
    visc: document.getElementById('visc-slider'),
    btns: {
        smooth: document.getElementById('btn-smooth'),
        texture: document.getElementById('btn-texture'),
        knife: document.getElementById('btn-knife'),
        undo: document.getElementById('btn-undo'),
        clear: document.getElementById('btn-clear'),
        save: document.getElementById('btn-save'),
        load: document.getElementById('btn-load')
    },
    status: document.getElementById('status')
};

// --- Utilities ---
const rnd = (min, max) => Math.random() * (max - min) + min;
const hexToRgb = (hex) => {
    const bigint = parseInt(hex.slice(1), 16);
    return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
};
const rgbToHex = (r, g, b) => "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);

// --- Spatial Hash Grid (Optimization) ---
// Divides canvas into cells to quickly find neighbors
class SpatialGrid {
    constructor(width, height, cellSize) {
        this.cellSize = cellSize;
        this.cols = Math.ceil(width / cellSize);
        this.rows = Math.ceil(height / cellSize);
        this.grid = new Array(this.cols * this.rows).fill(null).map(() => []);
    }

    clear() {
        for (let i = 0; i < this.grid.length; i++) this.grid[i].length = 0;
    }

    insert(particle) {
        const col = Math.floor(particle.x / this.cellSize);
        const row = Math.floor(particle.y / this.cellSize);
        if (col >= 0 && col < this.cols && row >= 0 && row < this.rows) {
            this.grid[row * this.cols + col].push(particle);
        }
    }

    // Get particles in 3x3 neighboring cells
    getNeighbors(x, y) {
        const col = Math.floor(x / this.cellSize);
        const row = Math.floor(y / this.cellSize);
        const neighbors = [];
        
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const c = col + i;
                const r = row + j;
                if (c >= 0 && c < this.cols && r >= 0 && r < this.rows) {
                    neighbors.push(...this.grid[r * this.cols + c]);
                }
            }
        }
        return neighbors;
    }
}

// --- Particle System ---
class PaintParticle {
    constructor(x, y, color, size, wetness, type) {
        this.x = x;
        this.y = y;
        this.color = color; // RGB object
        this.size = size;
        this.initialSize = size;
        this.wetness = wetness; // 0 = dry, 1 = very wet
        this.type = type; // 'smooth', 'texture', 'knife'
        this.life = 1.0; // For fading out old particles
        this.vx = 0; // Velocity (for smearing)
        this.vy = 0;
        
        // Texture generation (bump map)
        this.textureSeed = Math.random() * 1000;
    }

    update(dt, neighbors) {
        // 1. Drying
        if (this.wetness > 0) {
            this.wetness -= 0.005 * dt; // Drying rate
            if (this.wetness < 0) this.wetness = 0;
        }

        // 2. Physics (Smearing/Flow)
        // If wet, friction is lower, allowing movement
        if (this.wetness > 0.1) {
            // Apply drag (viscosity)
            this.vx *= 0.9;
            this.vy *= 0.9;
            
            // Gravity/Thickening (Oil paint piles up, but simplified here to spreading)
            // If neighbor is wet, exchange color slightly (diffusion)
            if (neighbors && neighbors.length > 0) {
                for (let n of neighbors) {
                    if (n === this) continue;
                    const dx = this.x - n.x;
                    const dy = this.y - n.y;
                    const distSq = dx*dx + dy*dy;
                    
                    // Collision/Mixing radius
                    const minDist = (this.size + n.size) * 0.6; 
                    
                    if (distSq < minDist * minDist && n.wetness > 0) {
                        // Color mixing (Diffusion)
                        const mixRatio = 0.05 * (this.wetness * n.wetness);
                        this.color.r = this.color.r * (1 - mixRatio) + n.color.r * mixRatio;
                        this.color.g = this.color.g * (1 - mixRatio) + n.color.g * mixRatio;
                        this.color.b = this.color.b * (1 - mixRatio) + n.color.b * mixRatio;
                        
                        // If "Knife" tool, it displaces paint (scatters it)
                        if (this.type === 'knife') {
                            const force = 1.5;
                            this.vx += (dx / Math.sqrt(distSq)) * force;
                            this.vy += (dy / Math.sqrt(distSq)) * force;
                        }
                    }
                }
            }
        }

        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;

        // Clamp to canvas
        if (this.x < 0) this.x = 0;
        if (this.y < 0) this.y = 0;
        if (this.x > canvas.width) this.x = canvas.width;
        if (this.y > canvas.height) this.y = canvas.height;
    }

    draw(ctx) {
        // Draw the particle
        ctx.save();
        ctx.translate(this.x, this.y);
        
        const alpha = Math.max(0.1, this.wetness + 0.3); // Wet paint looks more opaque
        
        // Base color
        ctx.fillStyle = `rgba(${Math.floor(this.color.r)}, ${Math.floor(this.color.g)}, ${Math.floor(this.color.b)}, ${alpha})`;
        
        // --- Visual Rendering based on Type ---
        
        if (this.type === 'smooth') {
            // Round brush with slight noise
            ctx.beginPath();
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            ctx.fill();
        } 
        else if (this.type === 'texture') {
            // Noise-based organic shape
            const points = 8;
            ctx.beginPath();
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * Math.PI * 2;
                // Distort radius with noise
                const r = this.size * (0.7 + Math.sin(this.textureSeed + i * 132.1) * 0.3);
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            
            // Add "Oil" ridge (High viscosity look)
            if (this.wetness > 0.5) {
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = `rgba(255,255,255, ${0.05 * this.wetness})`;
                ctx.beginPath();
                ctx.arc(-this.size*0.3, -this.size*0.3, this.size*0.4, 0, Math.PI*2);
                ctx.fill();
            }
        }
        else if (this.type === 'knife') {
            // Knife marks are flatter and sharper
            ctx.rotate(Math.sin(this.x * 0.01) * 0.5); // Random rotation
            ctx.fillStyle = `rgba(${Math.floor(this.color.r)}, ${Math.floor(this.color.g)}, ${Math.floor(this.color.b)}, ${alpha})`;
            ctx.beginPath();
            ctx.ellipse(0, 0, this.size * 1.2, this.size * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Sharp edge highlight
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = `rgba(255,255,255, ${0.1 * this.wetness})`;
            ctx.beginPath();
            ctx.ellipse(-this.size*0.2, -this.size*0.1, this.size, this.size*0.2, 0, 0, Math.PI*2);
            ctx.fill();
        }

        ctx.restore();
    }
}

// --- Main Engine ---
const grid = new SpatialGrid(window.innerWidth, window.innerHeight, 64);

function init() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    setupEvents();
    setupUI();
    requestAnimationFrame(loop);
}

function resizeCanvas() {
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    // Re-init grid
    grid.cols = Math.ceil(canvas.width / grid.cellSize);
    grid.rows = Math.ceil(canvas.height / grid.cellSize);
    grid.grid = new Array(grid.cols * grid.rows).fill(null).map(() => []);
    
    // Redraw background on resize
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function setupUI() {
    ui.color.addEventListener('input', (e) => state.color = e.target.value);
    ui.size.addEventListener('input', (e) => state.size = parseInt(e.target.value));
    ui.wet.addEventListener('input', (e) => state.wetness = parseInt(e.target.value) / 100);
    ui.visc.addEventListener('input', (e) => state.viscosity = parseInt(e.target.value) / 100);

    const tools = ['smooth', 'texture', 'knife'];
    tools.forEach(t => {
        ui.btns[t].addEventListener('click', () => {
            tools.forEach(x => ui.btns[x].classList.remove('active'));
            ui.btns[t].classList.add('active');
            state.tool = t;
            updateStatus(`Tool: ${t.charAt(0).toUpperCase() + t.slice(1)}`);
        });
    });

    ui.btns.undo.addEventListener('click', undo);
    ui.btns.clear.addEventListener('click', () => {
        state.particles = [];
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        updateStatus('Canvas Cleared');
    });
    ui.btns.save.addEventListener('click', saveDrawing);
    ui.btns.load.addEventListener('click', loadDrawing);
}

function setupEvents() {
    const start = (e) => {
        state.isDrawing = true;
        const { x, y } = getPos(e);
        state.lastX = x;
        state.lastY = y;
        addParticles(x, y, true); // Initial dab
    };

    const move = (e) => {
        if (!state.isDrawing) return;
        e.preventDefault();
        const { x, y } = getPos(e);
        
        // Interpolate for smoother strokes
        const dist = Math.hypot(x - state.lastX, y - state.lastY);
        const steps = Math.ceil(dist / (state.size * 0.3));
        
        for (let i = 1; i <= steps; i++) {
            const t = i / steps;
            const currX = state.lastX + (x - state.lastX) * t;
            const currY = state.lastY + (y - state.lastY) * t;
            addParticles(currX, currY);
        }

        state.lastX = x;
        state.lastY = y;
    };

    const end = () => {
        if (state.isDrawing) {
            state.isDrawing = false;
            saveState(); // Save to undo stack
        }
    };

    canvas.addEventListener('mousedown', start);
    window.addEventListener('mousemove', move);
    window.addEventListener('mouseup', end);
    
    canvas.addEventListener('touchstart', (e) => start(e.touches[0]), {passive: false});
    window.addEventListener('touchmove', (e) => move(e.touches[0]), {passive: false});
    window.addEventListener('touchend', end);
}

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function addParticles(x, y, isFirst = false) {
    const rgb = hexToRgb(state.color);
    const count = isFirst ? 1 : Math.ceil(state.viscosity * 5); // More particles if viscous
    
    for (let i = 0; i < count; i++) {
        if (state.particles.length >= state.maxParticles) {
            state.particles.shift(); // Remove oldest
        }

        // Random spread based on size
        const spread = state.size * (1 - state.viscosity * 0.8);
        const px = x + rnd(-spread/2, spread/2);
        const py = y + rnd(-spread/2, spread/2);
        
        // Variation in color for realism
        const vCol = {
            r: Math.max(0, Math.min(255, rgb.r + rnd(-10, 10))),
            g: Math.max(0, Math.min(255, rgb.g + rnd(-10, 10))),
            b: Math.max(0, Math.min(255, rgb.b + rnd(-10, 10)))
        };

        const p = new PaintParticle(
            px, py, 
            vCol, 
            rnd(state.size * 0.5, state.size * 1.2), 
            state.wetness,
            state.tool
        );
        
        // Add velocity in direction of motion for "drag" effect
        if (!isFirst) {
            p.vx = (x - state.lastX) * 0.2;
            p.vy = (y - state.lastY) * 0.2;
        }

        state.particles.push(p);
    }
}

// --- Main Loop ---
let lastTime = 0;
function loop(timestamp) {
    const dt = (timestamp - lastTime) / 16.67; // Normalize to 60fps
    lastTime = timestamp;

    // 1. Clear Grid
    grid.clear();

    // 2. Update Particles & Insert into Grid
    // We don't clear canvas here! Paint accumulates.
    // However, we need to "draw" the particles.
    // To keep persistent paint without clearing, we draw directly to the canvas.
    // BUT, for wet physics, we need to re-render wet particles every frame so they can move.
    // We need a strategy: 
    // - Dry particles are "baked" onto the canvas.
    // - Wet particles are drawn on top every frame.
    
    // Optimization: 
    // Iterate particles. If wetness is very low (< 0.05), bake it to background and remove from list.
    // If wet, update physics, draw it, and keep in list.

    const wetParticles = [];

    for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        
        // Get neighbors for physics
        const neighbors = grid.getNeighbors(p.x, p.y);
        
        p.update(dt, neighbors);
        
        if (p.wetness <= 0.05) {
            // Bake to background
            p.draw(ctx); 
        } else {
            // Keep wet
            wetParticles.push(p);
            grid.insert(p);
        }
    }

    // 3. Draw Wet Particles (on top)
    // We need to redraw the wet ones to show movement
    // Note: We don't clear the canvas, so we must draw wet particles freshly.
    // Since we aren't clearing, wet particles will leave trails.
    // This is actually good for "smearing"!
    
    // However, to avoid infinite accumulation of layers, we should draw wet particles
    // but since the canvas background hasn't cleared, we need to be careful.
    // The solution: We only draw wet particles. The baked ones are static.
    
    // Wait, if we don't clear, we redraw the same wet particle multiple times over itself.
    // That's okay, it just adds opacity.
    
    // Wait, actually, drawing to a canvas that already has data (without clearing) 
    // using `ctx.draw` is fine. It layers on top.
    
    // But: If a particle moves, it leaves a trail? 
    // Yes, we want the trail if it's wet (smearing). 
    // But we need to clear the *previous position* if we want rigid movement?
    // No, "Smearing" implies leaving a trail.
    
    // So, the logic is:
    // Canvas is persistent.
    // Wet particles are drawn.
    // They move.
    // They are drawn again.
    // Result: Smear trails.
    
    // However, if particles stack up too much, the color gets too dark.
    // We need to limit layering.
    
    // Better approach for this simulation:
    // 1. Canvas is static background (baked dry paint).
    // 2. Wet particles are rendered in a separate off-screen canvas? No, too heavy.
    // 3. We just draw wet particles. Since we aren't clearing, they stack.
    //    To prevent infinite darkening, we rely on the 'baking' step where low wetness stops updates.
    
    for (const p of wetParticles) {
        p.draw(ctx);
    }
    
    state.particles = wetParticles; // Update list

    requestAnimationFrame(loop);
}

// --- Undo / State Management ---
// Because we are manipulating canvas pixels directly (baking),
// we need to save the canvas state (DataURL) for Undo.
// We do this when a stroke ends.

function saveState() {
    if (state.undoStack.length >= state.maxUndo) state.undoStack.shift();
    // We save the current canvas state AND the wet particles list (serialized)
    const snapshot = {
        canvas: canvas.toDataURL('image/jpeg', 0.8),
        particles: state.particles.map(p => ({
            x: p.x, y: p.y, c: p.color, s: p.size, w: p.wetness, t: p.type
        }))
    };
    state.undoStack.push(snapshot);
    updateStatus('Saved State');
}

function undo() {
    if (state.undoStack.length === 0) {
        updateStatus('Nothing to undo');
        return;
    }
    
    const snapshot = state.undoStack.pop();
    const img = new Image();
    img.src = snapshot.canvas;
    img.onload = () => {
        // Restore baked paint
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
        
        // Restore wet particles
        state.particles = snapshot.particles.map(d => {
            const p = new PaintParticle(d.x, d.y, d.c, d.s, d.w, d.t);
            return p;
        });
        updateStatus('Undone');
    };
}

// --- Storage (LocalForage) ---
function saveDrawing() {
    if (!window.localforage) return;
    // Save just the image for now, simpler than saving all physics state
    const data = canvas.toDataURL('image/png');
    localforage.setItem('oilPainting', data).then(() => updateStatus('Saved to Disk'));
}

function loadDrawing() {
    if (!window.localforage) return;
    localforage.getItem('oilPainting').then((data) => {
        if (data) {
            const img = new Image();
            img.src = data;
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                state.particles = []; // Clear wet particles
                updateStatus('Loaded');
            };
        } else {
            updateStatus('No saved drawing');
        }
    });
}

function updateStatus(msg) {
    ui.status.textContent = msg;
    ui.status.style.opacity = 1;
    setTimeout(() => ui.status.style.opacity = 0, 1500);
}

// Start
init();

</script>
</body>
</html>