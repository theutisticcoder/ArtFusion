<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HTML5 Oil Painting Simulator</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-bg: #2d2d2d;
            --text-color: #e0e0e0;
            --accent: #ff9800;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Prevents scrolling on mobile */
        }

        /* Layout */
        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Toolbar */
        #toolbar {
            background-color: var(--panel-bg);
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #444;
            z-index: 10;
        }

        .group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding-right: 10px;
            border-right: 1px solid #444;
        }
        .group:last-child { border-right: none; }

        /* Controls */
        button {
            background: #444;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }

        button:hover { background: #555; }
        button.active { background: var(--accent); color: #000; font-weight: bold; }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 32px;
            height: 32px;
            cursor: pointer;
            background: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 4px; }

        input[type="range"] {
            width: 80px;
        }

        label {
            font-size: 0.8rem;
            color: #aaa;
        }

        /* Canvas Area */
        #canvas-container {
            flex: 1;
            position: relative;
            background-color: #fff; /* Canvas paper color */
            background-image: 
                linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* HUD Messages */
        #status {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        /* Responsive adjustments */
        @media (max-width: 600px) {
            #toolbar { gap: 5px; padding: 5px; overflow-x: auto; flex-wrap: nowrap; }
            .group { flex-shrink: 0; }
            label { display: none; }
            input[type="range"] { width: 60px; }
        }
    </style>
</head>
<body>

<div id="app">
    <div id="toolbar">
        <div class="group">
            <button id="btn-brush" class="active">Brush</button>
            <button id="btn-blur">Blur</button>
            <button id="btn-knife">Knife</button>
            <button id="btn-erase">Erase</button>
        </div>

        <div class="group">
            <label>Color</label>
            <input type="color" id="color-picker" value="#ff4500">
            <div id="palette" style="display:flex; gap:2px;">
                <!-- Swatches generated by JS -->
            </div>
        </div>

        <div class="group">
            <label>Size</label>
            <input type="range" id="size-slider" min="5" max="100" value="30">
        </div>

        <div class="group">
            <label>Load</label>
            <input type="range" id="flow-slider" min="1" max="100" value="50" title="Paint Load">
        </div>

        <div class="group">
            <button id="btn-undo">Undo</button>
            <button id="btn-clear">Clear</button>
            <button id="btn-save">Save</button>
            <button id="btn-load">Load</button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="art-canvas"></canvas>
    </div>

    <div id="status">Saved!</div>
</div>

<!-- Load LocalForage from CDN (Required for saving) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>

<script>
/**
 * OIL PAINT SIMULATION ENGINE
 * 
 * Core Logic:
 * 1. Rendering is done on a single <canvas> element.
 * 2. The simulation uses a particle approach where "dabs" of paint are applied 
 *    based on pointer movement speed.
 * 3. "Wetness" is simulated by mixing the brush color with the existing canvas 
 *    pixel data (destination-in / source-over composites).
 * 4. For the "Oil" look, we apply slight Gaussian blurs to dabs and use 
 *    randomized offsets to prevent robotic lines.
 */

const canvas = document.getElementById('art-canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const container = document.getElementById('canvas-container');

// State
const state = {
    isDrawing: false,
    tool: 'brush', // brush, blur, knife, erase
    color: '#ff4500',
    size: 30,
    flow: 0.5, // 0.0 to 1.0
    lastX: 0,
    lastY: 0,
    lastTime: 0,
    points: [], // For smoothing
    history: [], // Undo stack
    historyIndex: -1,
    maxHistory: 15
};

// Configuration
const CONFIG = {
    brushHardness: 0.2, // Softness of brush edges
    colorMixing: 0.15, // How aggressively colors blend (0-1)
    smearAmount: 2, // Smear distance
    samplingStep: 4 // Pixel sampling step for performance (lower = better quality, slower)
};

// UI Elements
const ui = {
    btnBrush: document.getElementById('btn-brush'),
    btnBlur: document.getElementById('btn-blur'),
    btnKnife: document.getElementById('btn-knife'),
    btnErase: document.getElementById('btn-erase'),
    colorPicker: document.getElementById('color-picker'),
    sizeSlider: document.getElementById('size-slider'),
    flowSlider: document.getElementById('flow-slider'),
    palette: document.getElementById('palette'),
    btnUndo: document.getElementById('btn-undo'),
    btnClear: document.getElementById('btn-clear'),
    btnSave: document.getElementById('btn-save'),
    btnLoad: document.getElementById('btn-load'),
    status: document.getElementById('status')
};

// --- INITIALIZATION ---

function init() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    setupControls();
    setupGestures();
    setupPalette();
    saveState(); // Initial blank state
    render(); // Start render loop
}

function resizeCanvas() {
    const rect = container.getBoundingClientRect();
    
    // Save current image data if resizing to prevent loss
    let imgData = null;
    if(canvas.width > 0) {
        imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    // Update dimensions
    canvas.width = rect.width;
    canvas.height = rect.height;

    // Restore image data (scaled)
    if (imgData) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = imgData.width;
        tempCanvas.height = imgData.height;
        tempCanvas.getContext('2d').putImageData(imgData, 0, 0);
        ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
    }
}

// --- CONTROLS & EVENTS ---

function setupControls() {
    // Tool Selection
    const tools = [
        { el: ui.btnBrush, tool: 'brush' },
        { el: ui.btnBlur, tool: 'blur' },
        { el: ui.btnKnife, tool: 'knife' },
        { el: ui.btnErase, tool: 'erase' }
    ];

    tools.forEach(t => {
        t.el.addEventListener('click', () => {
            tools.forEach(x => x.el.classList.remove('active'));
            t.el.classList.add('active');
            state.tool = t.tool;
        });
    });

    // Sliders & Color
    ui.colorPicker.addEventListener('input', (e) => state.color = e.target.value);
    ui.sizeSlider.addEventListener('input', (e) => state.size = parseInt(e.target.value));
    ui.flowSlider.addEventListener('input', (e) => state.flow = parseInt(e.target.value) / 100);

    // Actions
    ui.btnUndo.addEventListener('click', undo);
    ui.btnClear.addEventListener('click', () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        saveState();
    });
    ui.btnSave.addEventListener('click', saveToStorage);
    ui.btnLoad.addEventListener('click', loadFromStorage);
}

function setupPalette() {
    const colors = ['#ffffff', '#000000', '#ff4500', '#ff8c00', '#ffd700', '#adff2f', '#00ff7f', '#00bfff', '#1e90ff', '#9370db', '#8b4513', '#a0522d'];
    colors.forEach(c => {
        const swatch = document.createElement('div');
        swatch.style.width = '20px';
        swatch.style.height = '20px';
        swatch.style.backgroundColor = c;
        swatch.style.cursor = 'pointer';
        swatch.style.border = '1px solid #666';
        swatch.addEventListener('click', () => {
            state.color = c;
            ui.colorPicker.value = c;
        });
        ui.palette.appendChild(swatch);
    });
}

function setupGestures() {
    // Pointer Events for Mouse and Touch
    canvas.addEventListener('pointerdown', startDraw);
    canvas.addEventListener('pointermove', draw);
    window.addEventListener('pointerup', endDraw);
}

// --- DRAWING LOGIC ---

function startDraw(e) {
    e.preventDefault(); // Stop text selection/scrolling
    state.isDrawing = true;
    state.points = [];
    
    const { x, y } = getPos(e);
    state.lastX = x;
    state.lastY = y;
    state.lastTime = performance.now();

    // For "Wet" look, we might want to sample the initial color
    // but for simplicity, we just start the stroke
    
    // Single click dot
    if (state.tool === 'brush') {
        paintDot(x, y, state.size, state.color, state.flow);
    } else if (state.tool === 'erase') {
        eraseDot(x, y, state.size);
    }
}

function draw(e) {
    if (!state.isDrawing) return;
    e.preventDefault();

    const { x, y } = getPos(e);
    const now = performance.now();
    const dt = now - state.lastTime;

    // Calculate velocity for dynamic width
    const dist = Math.hypot(x - state.lastX, y - state.lastY);
    
    // Interpolate points based on speed to avoid gaps
    const steps = Math.ceil(dist / (state.size * 0.2));
    
    for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const currX = state.lastX + (x - state.lastX) * t;
        const currY = state.lastY + (y - state.lastY) * t;
        
        applyTool(currX, currY, dist, dt);
    }

    state.lastX = x;
    state.lastY = y;
    state.lastTime = now;
}

function endDraw() {
    if (state.isDrawing) {
        state.isDrawing = false;
        saveState(); // Save to undo stack
    }
}

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
}

function applyTool(x, y, speed, dt) {
    // Random jitter for natural look
    const jitter = (val) => val + (Math.random() - 0.5) * 2;
    const jx = jitter(x);
    const jy = jitter(y);

    switch (state.tool) {
        case 'brush':
            // Dynamic size based on speed (faster = thinner)
            const dynSize = Math.max(state.size * 0.5, state.size - (speed * 0.5));
            oilPaint(jx, jy, dynSize, state.color, state.flow);
            break;
        case 'blur':
            blurArea(jx, jy, state.size);
            break;
        case 'knife':
            smearArea(jx, jy, state.size, speed);
            break;
        case 'erase':
            eraseDot(jx, jy, state.size);
            break;
    }
}

// --- PAINTING ALGORITHMS ---

/**
 * Simulates Oil Paint.
 * Uses a radial gradient approach mixed with existing pixels.
 */
function oilPaint(x, y, radius, hexColor, opacity) {
    // Convert hex to RGB
    const rgb = hexToRgb(hexColor);
    
    // Create a temporary off-screen canvas for the dab
    // This is expensive to do per frame, but essential for realistic blending
    // Optimization: We draw directly to main canvas using globalCompositeOperation
    
    ctx.save();
    
    // 1. Set up the brush shape
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.closePath();
    
    // 2. Color Mixing Strategy
    // To simulate "wet" mixing, we draw the new color, but we use a composite operation
    // that interacts with what's already there.
    
    // We will use a layering approach:
    // First, draw the new color with some transparency.
    // Then, lightly blur it to simulate wet edges.
    
    ctx.fillStyle = hexColor;
    ctx.globalAlpha = opacity;
    
    // "Soft" brush texture simulation using shadow
    ctx.shadowBlur = radius * 0.5;
    ctx.shadowColor = hexColor;
    
    // Fill the dab
    ctx.fill();
    
    // Reset shadow for performance
    ctx.shadowBlur = 0;
    
    // 3. Wet Smear Simulation (Manual Pixel Manipulation on a small area)
    // This is the heaviest part. We do it only for the "Brush" tool effectively.
    // We grab the pixels under the brush, mix them, and put them back.
    
    // Sampling area
    const sx = Math.floor(x - radius);
    const sy = Math.floor(y - radius);
    const sw = radius * 2;
    const sh = radius * 2;

    // Boundary check
    if(sx < 0 || sy < 0 || sx + sw > canvas.width || sy + sh > canvas.height) {
        ctx.restore();
        return;
    }

    // Only do heavy mixing if flow is high enough
    if (state.tool === 'brush' && state.flow > 0.3) {
        try {
            const imgData = ctx.getImageData(sx, sy, sw, sh);
            const data = imgData.data;
            const len = data.length;
            
            // Pre-calculate new color components
            const rNew = rgb.r;
            const gNew = rgb.g;
            const bNew = rgb.b;
            
            // Mixing factor (0 to 1)
            // Higher flow = more new color dominates, but wetness allows old color to peek through
            const mixFactor = 0.1 + (state.flow * 0.4); 

            for (let i = 0; i < len; i += 4) {
                // Only process non-transparent pixels
                if (data[i + 3] > 0) {
                    // Simple distance-based mixing (closer to center = more new color)
                    const px = (i / 4) % sw;
                    const py = Math.floor((i / 4) / sw);
                    const dx = px - radius;
                    const dy = py - radius;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    // falloff from center
                    const falloff = Math.max(0, 1 - (dist / radius));
                    
                    // The "Oil" Effect: 
                    // We don't just blend. We push pixels slightly.
                    // But doing full fluid dynamics is too slow for JS.
                    // Visual hack: We mix the existing pixel with the new color
                    // using a slightly chaotic factor to avoid muddy colors.
                    
                    const oldR = data[i];
                    const oldG = data[i+1];
                    const oldB = data[i+2];
                    const oldA = data[i+3];

                    // "Wet" mixing formula
                    const w = mixFactor * falloff * (0.8 + Math.random() * 0.4); // Add noise to prevent banding
                    
                    data[i]   = oldR * (1 - w) + rNew * w;
                    data[i+1] = oldG * (1 - w) + gNew * w;
                    data[i+2] = oldB * (1 - w) + bNew * w;
                    // Keep alpha or slightly boost it for "thick" paint look
                    data[i+3] = Math.min(255, oldA + (w * 50)); 
                }
            }
            ctx.putImageData(imgData, sx, sy);
        } catch (e) {
            // Canvas may be tainted if we ever draw external images (not happening here)
            // or if out of memory. Fallback is just the simple fill.
        }
    }
    
    ctx.restore();
}

/**
 * Smear Tool (Knife)
 * Moves pixels in the direction of the stroke.
 */
function smearArea(x, y, radius, speed) {
    if (speed < 1) return; // Need movement to smear

    const sx = Math.floor(x - radius);
    const sy = Math.floor(y - radius);
    const w = radius * 2;
    const h = radius * 2;

    if(sx < 0 || sy < 0 || sx + w > canvas.width || sy + h > canvas.height) return;

    const imgData = ctx.getImageData(sx, sy, w, h);
    
    // Shift pixels based on direction (simplified smear)
    // We shift the array indices slightly
    const shift = Math.min(Math.floor(speed * 0.5), 4); // Max shift 4 pixels
    if(shift === 0) return;

    const data = imgData.data;
    const copy = new Uint8ClampedArray(data); // Backup

    // Simple smear logic: pull pixels from behind (opposite to movement)
    // Note: We don't know exact direction vector here without passing it, 
    // but we can approximate by shifting rows/columns based on mouse deltas.
    // For this simplified version, we just blur heavily to simulate blending edges.
    
    // Actually, let's make it a "Softener" / "Blender" for the Knife effect
    // as true directional smear requires complex vector math per pixel.
    // A "Blender" is very useful for oil painting anyway.
    
    // Apply a localized box blur
    const radiusSq = radius * radius;
    
    for (let i = 0; i < data.length; i += 4) {
        // Sample random neighbor
        const rOff = (Math.random() - 0.5) * radius;
        const cOff = (Math.random() - 0.5) * radius;
        
        const sampleX = Math.floor((i/4) % w + rOff);
        const sampleY = Math.floor((i/4) / w + cOff);
        
        if(sampleX >=0 && sampleX < w && sampleY >= 0 && sampleY < h) {
            const idx = (sampleY * w + sampleX) * 4;
            data[i] = copy[idx];
            data[i+1] = copy[idx+1];
            data[i+2] = copy[idx+2];
            // Alpha stays mostly same
        }
    }
    
    ctx.putImageData(imgData, sx, sy);
}

/**
 * Blur Tool
 * Gaussian-ish blur on a localized area.
 */
function blurArea(x, y, radius) {
    const sx = Math.floor(x - radius);
    const sy = Math.floor(y - radius);
    const w = radius * 2;
    const h = radius * 2;

    if(sx < 0 || sy < 0 || sx + w > canvas.width || sy + h > canvas.height) return;

    // Drawing a blurred circle with shadow is much faster than pixel manipulation
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.clip();
    
    // We can't easily blur existing pixels without read/write.
    // We use the composite trick: Draw the existing area on top with a blur filter
    // But filter is slow.
    // Alternative: Just "Smudge" the colors together (already handled by brush mixing).
    
    // Let's implement a localized "Gaussian Blur" via pixel sampling (Heavy but effective)
    try {
        const imgData = ctx.getImageData(sx, sy, w, h);
        const data = imgData.data;
        const copy = new Uint8ClampedArray(data);
        
        // 3x3 Kernel approximation
        for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
                const idx = (y * w + x) * 4;
                
                let r = 0, g = 0, b = 0, count = 0;
                
                // Neighbors
                for(let ky = -1; ky <= 1; ky++) {
                    for(let kx = -1; kx <= 1; kx++) {
                        const nIdx = ((y+ky) * w + (x+kx)) * 4;
                        r += copy[nIdx];
                        g += copy[nIdx+1];
                        b += copy[nIdx+2];
                        count++;
                    }
                }
                
                data[idx] = r / count;
                data[idx+1] = g / count;
                data[idx+2] = b / count;
                // Alpha remains
            }
        }
        ctx.putImageData(imgData, sx, sy);
    } catch(e) {}
    
    ctx.restore();
}

function eraseDot(x, y, radius) {
    ctx.save();
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,1)';
    ctx.fill();
    ctx.restore();
}

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
}

// --- UNDO / HISTORY ---

function saveState() {
    // Limit history size
    if (state.historyIndex < state.history.length - 1) {
        state.history = state.history.slice(0, state.historyIndex + 1);
    }
    
    // Get current image data
    // We store as DataURL string to be compatible with LocalForage easily
    // Compression reduces memory usage (0.7 is good balance)
    const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
    
    state.history.push(dataUrl);
    
    if (state.history.length > state.maxHistory) {
        state.history.shift();
    } else {
        state.historyIndex++;
    }
    
    updateUIStatus('State saved');
}

function undo() {
    if (state.historyIndex > 0) {
        state.historyIndex--;
        const img = new Image();
        img.src = state.history[state.historyIndex];
        img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        };
        updateUIStatus('Undo');
    } else if (state.historyIndex === 0) {
        // Clear to blank
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        state.historyIndex = -1;
        updateUIStatus('Undo');
    }
}

// --- STORAGE (LocalForage) ---

function saveToStorage() {
    if (!window.localforage) {
        updateUIStatus('Storage lib not loaded');
        return;
    }
    
    const dataUrl = canvas.toDataURL('image/png');
    localforage.setItem('oilPainting', dataUrl).then(() => {
        updateUIStatus('Saved to Local Storage');
    }).catch(err => {
        console.error(err);
        updateUIStatus('Save Failed');
    });
}

function loadFromStorage() {
    if (!window.localforage) return;
    
    localforage.getItem('oilPainting').then((dataUrl) => {
        if (dataUrl) {
            const img = new Image();
            img.src = dataUrl;
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                saveState(); // Add loaded image to undo stack
                updateUIStatus('Loaded');
            };
        } else {
            updateUIStatus('No saved drawing');
        }
    });
}

function updateUIStatus(msg) {
    ui.status.textContent = msg;
    ui.status.style.opacity = 1;
    setTimeout(() => {
        ui.status.style.opacity = 0;
    }, 1500);
}

// --- RENDER LOOP (Optional animations or dynamic brush preview) ---
// The main drawing happens in event handlers, but we can use this for cursor previews or drying simulation
function render() {
    // If we wanted to simulate paint drying (changing sheen), we would do it here.
    // For this version, we keep it static to save battery.
    requestAnimationFrame(render);
}

// Start
init();

</script>
</body>
</html>