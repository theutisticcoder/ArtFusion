<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Oil Painting Canvas</title>
<style>
  body { margin:0; overflow:hidden; background:#111; }
  #toolbar {
    position:fixed; top:10px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,0.5); padding:10px 20px; border-radius:8px;
    display:flex; gap:10px; align-items:center; z-index:10;
  }
  #toolbar > * { color:#fff; font-size:14px; }
  #toolbar input[type="color"] { width:30px; height:30px; border:none; }
  #toolbar input[type="range"] { width:80px; }
  #undoBtn, #saveBtn { padding:5px 10px; background:#006; color:#fff; border:none; border-radius:4px; cursor:pointer; }
  canvas { display:block; }
</style>
</head>
<body>
<div id="toolbar">
  <input id="sizeSlider" type="range" min="1" max="50" value="15">
  <input id="colorPicker" type="color" value="#ff6600">
  <select id="brushSelect">
    <option value="spatter">Spatter</option>
    <option value="wet">Wet Brush</option>
    <option value="dry">Dry Brush</option>
    <option value="palette">Palette Knife</option>
  </select>
  <button id="undoBtn">Undo</button>
  <button id="saveBtn">Save</button>
  <button id="eraseBtn">Eraser</button>
</div>
<canvas id="paintCanvas"></canvas>

<script type="module">
  // Load localforage from CDN
  importScripts('https://unpkg.com/localforage@1.10.0/localforage.min.js');

  const canvas = document.getElementById('paintCanvas');
  const ctx = canvas.getContext('2d');
  const undoStack = [];            // stores previous images as ImageBitmap
  const redoStack = [];

  // Resize canvas to fill window
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    loadBackground(); // redraw saved background if any
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Load previously saved image from localforage
  async function loadBackground() {
    const stored = await localforage.getItem('oilPainting');
    if (stored) {
      const img = new Image();
      img.onload = () => {
        ctx.drawImage(img, 0, 0);
      };
      img.src = stored;
    }
  }

  // Save current canvas to localforage
  async function saveDrawing() {
    const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
    await localforage.setItem('oilPainting', blob);
  }

  // ---------- Brushes ----------
  const brushes = {
    spatter: (x, y, rad, intensity) => {
      for (let i = 0; i < intensity * 5; i++) {
        const sx = x + (Math.random() - 0.5) * rad;
        const sy = y + (Math.random() - 0.5) * rad;
        ctx.fillStyle = currentColor;
        ctx.fillRect(sx, sy, rad * 0.6, rad * 0.6);
      }
    },
    wet: (x, y, rad, intensity) => {
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = currentColor;
      ctx.arc(x, y, rad, 0, Math.PI * 2);
      ctx.fill();
      // wet bleed
      ctx.globalCompositeOperation = 'lighter';
      const grad = ctx.createRadialGradient(x, y, rad * 0.2, x, y, rad);
      grad.addColorStop(0, 'rgba(255,255,255,0)');
      grad.addColorStop(1, 'rgba(255,255,255,0.1)');
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    },
    dry: (x, y, rad, intensity) => {
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = currentColor;
      ctx.lineWidth = rad * 0.5;
      ctx.beginPath();
      ctx.moveTo(x - rad, y);
      ctx.lineTo(x + rad, y);
      ctx.stroke();
      // add jitter
      for (let i = 0; i < intensity; i++) {
        const jitter = (Math.random() - 0.5) * rad * 0.3;
        ctx.beginPath();
        ctx.moveTo(x + jitter, y);
        ctx.lineTo(x - jitter, y);
        ctx.stroke();
      }
    },
    palette: (x, y, rad, intensity) => {
      // simple smear effect
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imgData.data;
      for (let i = 0; i < 5; i++) {
        const sx = x + (Math.random() - 0.5) * rad * 2;
        const sy = y + (Math.random() - 0.5) * rad * 2;
        const idx = (Math.floor(sy) * canvas.width + Math.floor(sx)) * 4;
        data[idx] = Math.min(255, data[idx] + 20);
        data[idx + 1] = Math.min(255, data[idx + 1] + 20);
        data[idx + 2] = Math.min(255, data[idx + 2] + 20);
      }
      ctx.putImageData(imgData, 0, 0);
    }
  };

  // ---------- State ----------
  let currentColor = '#ff6600';
  let isErasing = false;
  let brushName = 'wet';
  let brushRadius = 15;
  let isDrawing = false;
  let lastX = 0, lastY = 0;

  // ---------- Event Handlers ----------
  canvas.addEventListener('mousedown', startDrawing);
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    startDrawing(e.touches[0]);
  }, { passive: false });
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    draw(e.touches[0]);
  }, { passive: false });
  canvas.addEventListener('mouseup', endDrawing);
  canvas.addEventListener('mouseleave', endDrawing);
  canvas.addEventListener('touchend', endDrawing);
  canvas.addEventListener('touchcancel', endDrawing);

  function startDrawing(pt) {
    isDrawing = true;
    [lastX, lastY] = [pt.clientX, pt.clientY];
    pushUndo(); // store initial state before any stroke
  }
  function endDrawing() { isDrawing = false; }

  function pushUndo() {
    undoStack.push(canvas.convertToBlob().then(b => b)); // simplified placeholder
    // In practice weâ€™d store ImageBitmap via OffscreenCanvas; kept simple for brevity
  }

  function draw(pt) {
    if (!isDrawing) return;
    const ctx = canvas.getContext('2d');
    const dx = pt.clientX - lastX;
    const dy = pt.clientY - lastY;
    const distance = Math.hypot(dx, dy);
    // Simple smoothing
    const interpolated = {
      x: lastX + dx / distance * Math.min(distance, 5),
      y: lastY + dy / distance * Math.min(distance, 5)
    };
    // Choose brush
    if (brushes[brushName]) brushes[brushName](interpolated.x, interpolated.y, brushRadius, 1);
    // Save state for undo after a short delay to avoid flood
    setTimeout(pushUndo, 30);
    lastX = interpolated.x;
    lastY = interpolated.y;
  }

  // ---------- Toolbar ----------
  document.getElementById('sizeSlider').addEventListener('input', e => {
    brushRadius = parseInt(e.target.value);
  });
  document.getElementById('colorPicker').addEventListener('input', e => {
    currentColor = e.target.value;
  });
  document.getElementById('brushSelect').addEventListener('change', e => {
    brushName = e.target.value;
  });
  document.getElementById('eraseBtn').addEventListener('click', () => {
    isErasing = !isErasing;
    document.getElementById('eraseBtn').textContent = isErasing ? 'Paint' : 'Eraser';
  });
  document.getElementById('undoBtn').addEventListener('click', async () => {
    if (undoStack.length) {
      const last = undoStack.pop();
      const img = await createImageBitmap(last);
      const off = new OffscreenCanvas(canvas.width, canvas.height);
      const offCtx = off.getContext('2d');
      offCtx.drawImage(img, 0, 0);
      ctx.drawImage(off, 0, 0);
      // push to redo stack
      redoStack.push(canvas.convertToBlob());
    }
  });
  document.getElementById('saveBtn').addEventListener('click', saveDrawing);

  // ---------- Helper Functions ----------
  function createImageBitmap(blob) {
    return new Promise(r => {
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          const off = new OffscreenCanvas(canvas.width, canvas.height);
          const ctx = off.getContext('2d');
          ctx.drawImage(img, 0, 0);
          r(ctx.getImageBitmap(off));
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(blob);
    });
  }
</script>
</body>
</html>